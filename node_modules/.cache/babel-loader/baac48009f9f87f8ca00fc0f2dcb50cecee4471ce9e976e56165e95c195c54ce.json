{"ast":null,"code":"/**\r\n * react-router v7.12.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\n\"use client\";\n\nimport { RSCRouterGlobalErrorBoundary, deserializeErrors, getHydrationData, populateRSCRouteModules } from \"./chunk-FNSCYPCZ.mjs\";\nimport { CRITICAL_CSS_DATA_ATTRIBUTE, ErrorResponseImpl, FrameworkContext, RSCRouterContext, RemixErrorBoundary, RouterProvider, createBrowserHistory, createClientRoutes, createClientRoutesWithHMRRevalidationOptOut, createContext, createRequestInit, createRouter, decodeViaTurboStream, getPatchRoutesOnNavigationFunction, getSingleFetchDataStrategyImpl, getTurboStreamSingleFetchDataStrategy, hydrationRouteProperties, invariant, isMutationMethod, mapRouteProperties, noActionDefinedError, setIsHydrated, shouldHydrateRouteLoader, singleFetchUrl, stripIndexParam, useFogOFWarDiscovery } from \"./chunk-EPOLDU6W.mjs\";\n\n// lib/dom-export/dom-router-provider.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nfunction RouterProvider2(props) {\n  return /* @__PURE__ */React.createElement(RouterProvider, {\n    flushSync: ReactDOM.flushSync,\n    ...props\n  });\n}\n\n// lib/dom-export/hydrated-router.tsx\nimport * as React2 from \"react\";\nvar ssrInfo = null;\nvar router = null;\nfunction initSsrInfo() {\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\n    if (window.__reactRouterManifest.sri === true) {\n      const importMap = document.querySelector(\"script[rr-importmap]\");\n      if (importMap?.textContent) {\n        try {\n          window.__reactRouterManifest.sri = JSON.parse(importMap.textContent).integrity;\n        } catch (err) {\n          console.error(\"Failed to parse import map\", err);\n        }\n      }\n    }\n    ssrInfo = {\n      context: window.__reactRouterContext,\n      manifest: window.__reactRouterManifest,\n      routeModules: window.__reactRouterRouteModules,\n      stateDecodingPromise: void 0,\n      router: void 0,\n      routerInitialized: false\n    };\n  }\n}\nfunction createHydratedRouter({\n  getContext,\n  unstable_instrumentations\n}) {\n  initSsrInfo();\n  if (!ssrInfo) {\n    throw new Error(\"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\");\n  }\n  let localSsrInfo = ssrInfo;\n  if (!ssrInfo.stateDecodingPromise) {\n    let stream = ssrInfo.context.stream;\n    invariant(stream, \"No stream found for single fetch decoding\");\n    ssrInfo.context.stream = void 0;\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then(value => {\n      ssrInfo.context.state = value.value;\n      localSsrInfo.stateDecodingPromise.value = true;\n    }).catch(e => {\n      localSsrInfo.stateDecodingPromise.error = e;\n    });\n  }\n  if (ssrInfo.stateDecodingPromise.error) {\n    throw ssrInfo.stateDecodingPromise.error;\n  }\n  if (!ssrInfo.stateDecodingPromise.value) {\n    throw ssrInfo.stateDecodingPromise;\n  }\n  let routes = createClientRoutes(ssrInfo.manifest.routes, ssrInfo.routeModules, ssrInfo.context.state, ssrInfo.context.ssr, ssrInfo.context.isSpaMode);\n  let hydrationData = void 0;\n  if (ssrInfo.context.isSpaMode) {\n    let {\n      loaderData\n    } = ssrInfo.context.state;\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\n      hydrationData = {\n        loaderData: {\n          root: loaderData.root\n        }\n      };\n    }\n  } else {\n    hydrationData = getHydrationData({\n      state: ssrInfo.context.state,\n      routes,\n      getRouteInfo: routeId => ({\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\n      }),\n      location: window.location,\n      basename: window.__reactRouterContext?.basename,\n      isSpaMode: ssrInfo.context.isSpaMode\n    });\n    if (hydrationData && hydrationData.errors) {\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\n    }\n  }\n  let router2 = createRouter({\n    routes,\n    history: createBrowserHistory(),\n    basename: ssrInfo.context.basename,\n    getContext,\n    hydrationData,\n    hydrationRouteProperties,\n    unstable_instrumentations,\n    mapRouteProperties,\n    future: {\n      middleware: ssrInfo.context.future.v8_middleware\n    },\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(() => router2, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.basename, ssrInfo.context.future.unstable_trailingSlashAwareDataRequests),\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode, ssrInfo.context.basename)\n  });\n  ssrInfo.router = router2;\n  if (router2.state.initialized) {\n    ssrInfo.routerInitialized = true;\n    router2.initialize();\n  }\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\n  createClientRoutesWithHMRRevalidationOptOut;\n  window.__reactRouterDataRouter = router2;\n  return router2;\n}\nfunction HydratedRouter(props) {\n  if (!router) {\n    router = createHydratedRouter({\n      getContext: props.getContext,\n      unstable_instrumentations: props.unstable_instrumentations\n    });\n  }\n  let [criticalCss, setCriticalCss] = React2.useState(process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\") {\n      setCriticalCss(void 0);\n    }\n  }, []);\n  React2.useEffect(() => {\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach(element => element.remove());\n    }\n  }, [criticalCss]);\n  let [location2, setLocation] = React2.useState(router.state.location);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\n      ssrInfo.routerInitialized = true;\n      ssrInfo.router.initialize();\n    }\n  }, []);\n  React2.useLayoutEffect(() => {\n    if (ssrInfo && ssrInfo.router) {\n      return ssrInfo.router.subscribe(newState => {\n        if (newState.location !== location2) {\n          setLocation(newState.location);\n        }\n      });\n    }\n  }, [location2]);\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\n  useFogOFWarDiscovery(router, ssrInfo.manifest, ssrInfo.routeModules, ssrInfo.context.ssr, ssrInfo.context.routeDiscovery, ssrInfo.context.isSpaMode);\n  return (\n    // This fragment is important to ensure we match the <ServerRouter> JSX\n    // structure so that useId values hydrate correctly\n    /* @__PURE__ */\n    React2.createElement(React2.Fragment, null, /* @__PURE__ */React2.createElement(FrameworkContext.Provider, {\n      value: {\n        manifest: ssrInfo.manifest,\n        routeModules: ssrInfo.routeModules,\n        future: ssrInfo.context.future,\n        criticalCss,\n        ssr: ssrInfo.context.ssr,\n        isSpaMode: ssrInfo.context.isSpaMode,\n        routeDiscovery: ssrInfo.context.routeDiscovery\n      }\n    }, /* @__PURE__ */React2.createElement(RemixErrorBoundary, {\n      location: location2\n    }, /* @__PURE__ */React2.createElement(RouterProvider2, {\n      router,\n      unstable_useTransitions: props.unstable_useTransitions,\n      onError: props.onError\n    }))), /* @__PURE__ */React2.createElement(React2.Fragment, null))\n  );\n}\n\n// lib/rsc/browser.tsx\nimport * as React3 from \"react\";\nimport * as ReactDOM2 from \"react-dom\";\nfunction createCallServer({\n  createFromReadableStream,\n  createTemporaryReferenceSet,\n  encodeReply,\n  fetch: fetchImplementation = fetch\n}) {\n  const globalVar = window;\n  let landedActionId = 0;\n  return async (id, args) => {\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    const temporaryReferences = createTemporaryReferenceSet();\n    const payloadPromise = fetchImplementation(new Request(location.href, {\n      body: await encodeReply(args, {\n        temporaryReferences\n      }),\n      method: \"POST\",\n      headers: {\n        Accept: \"text/x-component\",\n        \"rsc-action-id\": id\n      }\n    })).then(response => {\n      if (!response.body) {\n        throw new Error(\"No response body\");\n      }\n      return createFromReadableStream(response.body, {\n        temporaryReferences\n      });\n    });\n    React3.startTransition(() =>\n    // @ts-expect-error - Needs React 19 types\n    Promise.resolve(payloadPromise).then(async payload => {\n      if (payload.type === \"redirect\") {\n        if (payload.reload || isExternalLocation(payload.location)) {\n          window.location.href = payload.location;\n          return;\n        }\n        React3.startTransition(() => {\n          globalVar.__reactRouterDataRouter.navigate(payload.location, {\n            replace: payload.replace\n          });\n        });\n        return;\n      }\n      if (payload.type !== \"action\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      const rerender = await payload.rerender;\n      if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\n        if (rerender.type === \"redirect\") {\n          if (rerender.reload || isExternalLocation(rerender.location)) {\n            window.location.href = rerender.location;\n            return;\n          }\n          React3.startTransition(() => {\n            globalVar.__reactRouterDataRouter.navigate(rerender.location, {\n              replace: rerender.replace\n            });\n          });\n          return;\n        }\n        React3.startTransition(() => {\n          let lastMatch;\n          for (const match of rerender.matches) {\n            globalVar.__reactRouterDataRouter.patchRoutes(lastMatch?.id ?? null, [createRouteFromServerManifest(match)], true);\n            lastMatch = match;\n          }\n          window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp({\n            loaderData: Object.assign({}, globalVar.__reactRouterDataRouter.state.loaderData, rerender.loaderData),\n            errors: rerender.errors ? Object.assign({}, globalVar.__reactRouterDataRouter.state.errors, rerender.errors) : null\n          });\n        });\n      }\n    }).catch(() => {}));\n    return payloadPromise.then(payload => {\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      return payload.actionResult;\n    });\n  };\n}\nfunction createRouterFromPayload({\n  fetchImplementation,\n  createFromReadableStream,\n  getContext,\n  payload\n}) {\n  const globalVar = window;\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules) return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\n  let patches = /* @__PURE__ */new Map();\n  payload.patches?.forEach(patch => {\n    invariant(patch.parentId, \"Invalid patch parentId\");\n    if (!patches.has(patch.parentId)) {\n      patches.set(patch.parentId, []);\n    }\n    patches.get(patch.parentId)?.push(patch);\n  });\n  let routes = payload.matches.reduceRight((previous, match) => {\n    const route = createRouteFromServerManifest(match, payload);\n    if (previous.length > 0) {\n      route.children = previous;\n      let childrenToPatch = patches.get(match.id);\n      if (childrenToPatch) {\n        route.children.push(...childrenToPatch.map(r => createRouteFromServerManifest(r)));\n      }\n    }\n    return [route];\n  }, []);\n  globalVar.__reactRouterDataRouter = createRouter({\n    routes,\n    getContext,\n    basename: payload.basename,\n    history: createBrowserHistory(),\n    hydrationData: getHydrationData({\n      state: {\n        loaderData: payload.loaderData,\n        actionData: payload.actionData,\n        errors: payload.errors\n      },\n      routes,\n      getRouteInfo: routeId => {\n        let match = payload.matches.find(m => m.id === routeId);\n        invariant(match, \"Route not found in payload\");\n        return {\n          clientLoader: match.clientLoader,\n          hasLoader: match.hasLoader,\n          hasHydrateFallback: match.hydrateFallbackElement != null\n        };\n      },\n      location: payload.location,\n      basename: payload.basename,\n      isSpaMode: false\n    }),\n    async patchRoutesOnNavigation({\n      path,\n      signal\n    }) {\n      if (discoveredPaths.has(path)) {\n        return;\n      }\n      await fetchAndApplyManifestPatches([path], createFromReadableStream, fetchImplementation, signal);\n    },\n    // FIXME: Pass `build.ssr` into this function\n    dataStrategy: getRSCSingleFetchDataStrategy(() => globalVar.__reactRouterDataRouter, true, payload.basename, createFromReadableStream, fetchImplementation)\n  });\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\n    globalVar.__routerInitialized = true;\n    globalVar.__reactRouterDataRouter.initialize();\n  } else {\n    globalVar.__routerInitialized = false;\n  }\n  let lastLoaderData = void 0;\n  globalVar.__reactRouterDataRouter.subscribe(({\n    loaderData,\n    actionData\n  }) => {\n    if (lastLoaderData !== loaderData) {\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\n    }\n  });\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = routeUpdateByRouteId => {\n    const oldRoutes = window.__reactRouterDataRouter.routes;\n    const newRoutes = [];\n    function walkRoutes(routes2, parentId) {\n      return routes2.map(route => {\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\n        if (routeUpdate) {\n          const {\n            routeModule,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader\n          } = routeUpdate;\n          const newRoute = createRouteFromServerManifest({\n            clientAction: routeModule.clientAction,\n            clientLoader: routeModule.clientLoader,\n            element: route.element,\n            errorElement: route.errorElement,\n            handle: route.handle,\n            hasAction,\n            hasComponent,\n            hasErrorBoundary,\n            hasLoader,\n            hydrateFallbackElement: route.hydrateFallbackElement,\n            id: route.id,\n            index: route.index,\n            links: routeModule.links,\n            meta: routeModule.meta,\n            parentId,\n            path: route.path,\n            shouldRevalidate: routeModule.shouldRevalidate\n          });\n          if (route.children) {\n            newRoute.children = walkRoutes(route.children, route.id);\n          }\n          return newRoute;\n        }\n        const updatedRoute = {\n          ...route\n        };\n        if (route.children) {\n          updatedRoute.children = walkRoutes(route.children, route.id);\n        }\n        return updatedRoute;\n      });\n    }\n    newRoutes.push(...walkRoutes(oldRoutes, void 0));\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\n  };\n  return {\n    router: globalVar.__reactRouterDataRouter,\n    routeModules: globalVar.__reactRouterRouteModules\n  };\n}\nvar renderedRoutesContext = createContext();\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\n  let dataStrategy = getSingleFetchDataStrategyImpl(getRouter, match => {\n    let M = match;\n    return {\n      hasLoader: M.route.hasLoader,\n      hasClientLoader: M.route.hasClientLoader,\n      hasComponent: M.route.hasComponent,\n      hasAction: M.route.hasAction,\n      hasClientAction: M.route.hasClientAction,\n      hasShouldRevalidate: M.route.hasShouldRevalidate\n    };\n  },\n  // pass map into fetchAndDecode so it can add payloads\n  getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation), ssr, basename,\n  // .rsc requests are always trailing slash aware\n  true,\n  // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match => {\n    let M = match;\n    return M.route.hasComponent && !M.route.element;\n  });\n  return async args => args.runClientMiddleware(async () => {\n    let context = args.context;\n    context.set(renderedRoutesContext, []);\n    let results = await dataStrategy(args);\n    const renderedRoutesById = /* @__PURE__ */new Map();\n    for (const route of context.get(renderedRoutesContext)) {\n      if (!renderedRoutesById.has(route.id)) {\n        renderedRoutesById.set(route.id, []);\n      }\n      renderedRoutesById.get(route.id).push(route);\n    }\n    React3.startTransition(() => {\n      for (const match of args.matches) {\n        const renderedRoutes = renderedRoutesById.get(match.route.id);\n        if (renderedRoutes) {\n          for (const rendered of renderedRoutes) {\n            window.__reactRouterDataRouter.patchRoutes(rendered.parentId ?? null, [createRouteFromServerManifest(rendered)], true);\n          }\n        }\n      }\n    });\n    return results;\n  });\n}\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\n  return async (args, basename, trailingSlashAware, targetRoutes) => {\n    let {\n      request,\n      context\n    } = args;\n    let url = singleFetchUrl(request.url, basename, trailingSlashAware, \"rsc\");\n    if (request.method === \"GET\") {\n      url = stripIndexParam(url);\n      if (targetRoutes) {\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\n      }\n    }\n    let res = await fetchImplementation(new Request(url, await createRequestInit(request)));\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\n    }\n    invariant(res.body, \"No response body to decode\");\n    try {\n      const payload = await createFromReadableStream(res.body, {\n        temporaryReferences: void 0\n      });\n      if (payload.type === \"redirect\") {\n        return {\n          status: res.status,\n          data: {\n            redirect: {\n              redirect: payload.location,\n              reload: payload.reload,\n              replace: payload.replace,\n              revalidate: false,\n              status: payload.status\n            }\n          }\n        };\n      }\n      if (payload.type !== \"render\") {\n        throw new Error(\"Unexpected payload type\");\n      }\n      context.get(renderedRoutesContext).push(...payload.matches);\n      let results = {\n        routes: {}\n      };\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\n        results.routes[routeId] = {\n          data\n        };\n      }\n      if (payload.errors) {\n        for (let [routeId, error] of Object.entries(payload.errors)) {\n          results.routes[routeId] = {\n            error\n          };\n        }\n      }\n      return {\n        status: res.status,\n        data: results\n      };\n    } catch (e) {\n      throw new Error(\"Unable to decode RSC response\");\n    }\n  };\n}\nfunction RSCHydratedRouter({\n  createFromReadableStream,\n  fetch: fetchImplementation = fetch,\n  payload,\n  routeDiscovery = \"eager\",\n  getContext\n}) {\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\n  let {\n    router: router2,\n    routeModules\n  } = React3.useMemo(() => createRouterFromPayload({\n    payload,\n    fetchImplementation,\n    getContext,\n    createFromReadableStream\n  }), [createFromReadableStream, payload, fetchImplementation, getContext]);\n  React3.useEffect(() => {\n    setIsHydrated();\n  }, []);\n  React3.useLayoutEffect(() => {\n    const globalVar = window;\n    if (!globalVar.__routerInitialized) {\n      globalVar.__routerInitialized = true;\n      globalVar.__reactRouterDataRouter.initialize();\n    }\n  }, []);\n  let [{\n    routes,\n    state\n  }, setState] = React3.useState(() => ({\n    routes: cloneRoutes(router2.routes),\n    state: router2.state\n  }));\n  React3.useLayoutEffect(() => router2.subscribe(newState => {\n    if (diffRoutes(router2.routes, routes)) React3.startTransition(() => {\n      setState({\n        routes: cloneRoutes(router2.routes),\n        state: newState\n      });\n    });\n  }), [router2.subscribe, routes, router2]);\n  const transitionEnabledRouter = React3.useMemo(() => ({\n    ...router2,\n    state,\n    routes\n  }), [router2, routes, state]);\n  React3.useEffect(() => {\n    if (routeDiscovery === \"lazy\" ||\n    // @ts-expect-error - TS doesn't know about this yet\n    window.navigator?.connection?.saveData === true) {\n      return;\n    }\n    function registerElement(el) {\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\n      if (!path) {\n        return;\n      }\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\n      if (!discoveredPaths.has(pathname)) {\n        nextPaths.add(pathname);\n      }\n    }\n    async function fetchPatches() {\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\n      let paths = Array.from(nextPaths.keys()).filter(path => {\n        if (discoveredPaths.has(path)) {\n          nextPaths.delete(path);\n          return false;\n        }\n        return true;\n      });\n      if (paths.length === 0) {\n        return;\n      }\n      try {\n        await fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation);\n      } catch (e) {\n        console.error(\"Failed to fetch manifest patches\", e);\n      }\n    }\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\n    fetchPatches();\n    let observer = new MutationObserver(() => debouncedFetchPatches());\n    observer.observe(document.documentElement, {\n      subtree: true,\n      childList: true,\n      attributes: true,\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\n    });\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\n  const frameworkContext = {\n    future: {\n      // These flags have no runtime impact so can always be false.  If we add\n      // flags that drive runtime behavior they'll need to be proxied through.\n      v8_middleware: false,\n      unstable_subResourceIntegrity: false,\n      unstable_trailingSlashAwareDataRequests: true\n      // always on for RSC\n    },\n    isSpaMode: false,\n    ssr: true,\n    criticalCss: \"\",\n    manifest: {\n      routes: {},\n      version: \"1\",\n      url: \"\",\n      entry: {\n        module: \"\",\n        imports: []\n      }\n    },\n    routeDiscovery: {\n      mode: \"lazy\",\n      manifestPath: \"/__manifest\"\n    },\n    routeModules\n  };\n  return /* @__PURE__ */React3.createElement(RSCRouterContext.Provider, {\n    value: true\n  }, /* @__PURE__ */React3.createElement(RSCRouterGlobalErrorBoundary, {\n    location: state.location\n  }, /* @__PURE__ */React3.createElement(FrameworkContext.Provider, {\n    value: frameworkContext\n  }, /* @__PURE__ */React3.createElement(RouterProvider, {\n    router: transitionEnabledRouter,\n    flushSync: ReactDOM2.flushSync\n  }))));\n}\nfunction createRouteFromServerManifest(match, payload) {\n  let hasInitialData = payload && match.id in payload.loaderData;\n  let initialData = payload?.loaderData[match.id];\n  let hasInitialError = payload?.errors && match.id in payload.errors;\n  let initialError = payload?.errors?.[match.id];\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader ||\n  // If the route has a component but we don't have an element, we need to hit\n  // the server loader flow regardless of whether the client loader calls\n  // `serverLoader` or not, otherwise we'll have nothing to render.\n  match.hasComponent && !match.element;\n  invariant(window.__reactRouterRouteModules);\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\n  let dataRoute = {\n    id: match.id,\n    element: match.element,\n    errorElement: match.errorElement,\n    handle: match.handle,\n    hasErrorBoundary: match.hasErrorBoundary,\n    hydrateFallbackElement: match.hydrateFallbackElement,\n    index: match.index,\n    loader: match.clientLoader ? async (args, singleFetch) => {\n      try {\n        let result = await match.clientLoader({\n          ...args,\n          serverLoader: () => {\n            preventInvalidServerHandlerCall(\"loader\", match.id, match.hasLoader);\n            if (isHydrationRequest) {\n              if (hasInitialData) {\n                return initialData;\n              }\n              if (hasInitialError) {\n                throw initialError;\n              }\n            }\n            return callSingleFetch(singleFetch);\n          }\n        });\n        return result;\n      } finally {\n        isHydrationRequest = false;\n      }\n    } :\n    // We always make the call in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    (_, singleFetch) => callSingleFetch(singleFetch),\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\n      ...args,\n      serverAction: async () => {\n        preventInvalidServerHandlerCall(\"action\", match.id, match.hasLoader);\n        return await callSingleFetch(singleFetch);\n      }\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\n      throw noActionDefinedError(\"action\", match.id);\n    },\n    path: match.path,\n    shouldRevalidate: match.shouldRevalidate,\n    // We always have a \"loader\" in this RSC world since even if we don't\n    // have a `loader` we may need to get the `element` implementation\n    hasLoader: true,\n    hasClientLoader: match.clientLoader != null,\n    hasAction: match.hasAction,\n    hasClientAction: match.clientAction != null,\n    hasShouldRevalidate: match.shouldRevalidate != null\n  };\n  if (typeof dataRoute.loader === \"function\") {\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(match.id, match.clientLoader, match.hasLoader, false);\n  }\n  return dataRoute;\n}\nfunction callSingleFetch(singleFetch) {\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\n  return singleFetch();\n}\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\n  if (!hasHandler) {\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\n    console.error(msg);\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\n  }\n}\nvar nextPaths = /* @__PURE__ */new Set();\nvar discoveredPathsMaxSize = 1e3;\nvar discoveredPaths = /* @__PURE__ */new Set();\nvar URL_LIMIT = 7680;\nfunction getManifestUrl(paths) {\n  if (paths.length === 0) {\n    return null;\n  }\n  if (paths.length === 1) {\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\n  }\n  const globalVar = window;\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(/^\\/|\\/$/g, \"\");\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\n  return url;\n}\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\n  let url = getManifestUrl(paths);\n  if (url == null) {\n    return;\n  }\n  if (url.toString().length > URL_LIMIT) {\n    nextPaths.clear();\n    return;\n  }\n  let response = await fetchImplementation(new Request(url, {\n    signal\n  }));\n  if (!response.body || response.status < 200 || response.status >= 300) {\n    throw new Error(\"Unable to fetch new route matches from the server\");\n  }\n  let payload = await createFromReadableStream(response.body, {\n    temporaryReferences: void 0\n  });\n  if (payload.type !== \"manifest\") {\n    throw new Error(\"Failed to patch routes\");\n  }\n  paths.forEach(p => addToFifoQueue(p, discoveredPaths));\n  React3.startTransition(() => {\n    payload.patches.forEach(p => {\n      window.__reactRouterDataRouter.patchRoutes(p.parentId ?? null, [createRouteFromServerManifest(p)]);\n    });\n  });\n}\nfunction addToFifoQueue(path, queue) {\n  if (queue.size >= discoveredPathsMaxSize) {\n    let first = queue.values().next().value;\n    if (typeof first === \"string\") queue.delete(first);\n  }\n  queue.add(path);\n}\nfunction debounce(callback, wait) {\n  let timeoutId;\n  return (...args) => {\n    window.clearTimeout(timeoutId);\n    timeoutId = window.setTimeout(() => callback(...args), wait);\n  };\n}\nfunction isExternalLocation(location2) {\n  const newLocation = new URL(location2, window.location.href);\n  return newLocation.origin !== window.location.origin;\n}\nfunction cloneRoutes(routes) {\n  if (!routes) return void 0;\n  return routes.map(route => ({\n    ...route,\n    children: cloneRoutes(route.children)\n  }));\n}\nfunction diffRoutes(a, b) {\n  if (a.length !== b.length) return true;\n  return a.some((route, index) => {\n    if (route.element !== b[index].element) return true;\n    if (route.errorElement !== b[index].errorElement) return true;\n    if (route.hydrateFallbackElement !== b[index].hydrateFallbackElement) return true;\n    if (route.hasErrorBoundary !== b[index].hasErrorBoundary) return true;\n    if (route.hasLoader !== b[index].hasLoader) return true;\n    if (route.hasClientLoader !== b[index].hasClientLoader) return true;\n    if (route.hasAction !== b[index].hasAction) return true;\n    if (route.hasClientAction !== b[index].hasClientAction) return true;\n    return diffRoutes(route.children || [], b[index].children || []);\n  });\n}\n\n// lib/rsc/html-stream/browser.ts\nfunction getRSCStream() {\n  let encoder = new TextEncoder();\n  let streamController = null;\n  let rscStream = new ReadableStream({\n    start(controller) {\n      if (typeof window === \"undefined\") {\n        return;\n      }\n      let handleChunk = chunk => {\n        if (typeof chunk === \"string\") {\n          controller.enqueue(encoder.encode(chunk));\n        } else {\n          controller.enqueue(chunk);\n        }\n      };\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\n      window.__FLIGHT_DATA.forEach(handleChunk);\n      window.__FLIGHT_DATA.push = chunk => {\n        handleChunk(chunk);\n        return 0;\n      };\n      streamController = controller;\n    }\n  });\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\n    document.addEventListener(\"DOMContentLoaded\", () => {\n      streamController?.close();\n    });\n  } else {\n    streamController?.close();\n  }\n  return rscStream;\n}\nexport { HydratedRouter, RouterProvider2 as RouterProvider, RSCHydratedRouter as unstable_RSCHydratedRouter, createCallServer as unstable_createCallServer, getRSCStream as unstable_getRSCStream };","map":{"version":3,"names":["RSCRouterGlobalErrorBoundary","deserializeErrors","getHydrationData","populateRSCRouteModules","CRITICAL_CSS_DATA_ATTRIBUTE","ErrorResponseImpl","FrameworkContext","RSCRouterContext","RemixErrorBoundary","RouterProvider","createBrowserHistory","createClientRoutes","createClientRoutesWithHMRRevalidationOptOut","createContext","createRequestInit","createRouter","decodeViaTurboStream","getPatchRoutesOnNavigationFunction","getSingleFetchDataStrategyImpl","getTurboStreamSingleFetchDataStrategy","hydrationRouteProperties","invariant","isMutationMethod","mapRouteProperties","noActionDefinedError","setIsHydrated","shouldHydrateRouteLoader","singleFetchUrl","stripIndexParam","useFogOFWarDiscovery","React","ReactDOM","RouterProvider2","props","createElement","flushSync","React2","ssrInfo","router","initSsrInfo","window","__reactRouterContext","__reactRouterManifest","__reactRouterRouteModules","sri","importMap","document","querySelector","textContent","JSON","parse","integrity","err","console","error","context","manifest","routeModules","stateDecodingPromise","routerInitialized","createHydratedRouter","getContext","unstable_instrumentations","Error","localSsrInfo","stream","then","value","state","catch","e","routes","ssr","isSpaMode","hydrationData","loaderData","root","hasLoader","getRouteInfo","routeId","clientLoader","hasHydrateFallback","HydrateFallback","location","basename","errors","router2","history","future","middleware","v8_middleware","dataStrategy","unstable_trailingSlashAwareDataRequests","patchRoutesOnNavigation","routeDiscovery","initialized","initialize","createRoutesForHMR","__reactRouterDataRouter","HydratedRouter","criticalCss","setCriticalCss","useState","process","env","NODE_ENV","useEffect","querySelectorAll","forEach","element","remove","location2","setLocation","useLayoutEffect","subscribe","newState","Fragment","Provider","unstable_useTransitions","onError","React3","ReactDOM2","createCallServer","createFromReadableStream","createTemporaryReferenceSet","encodeReply","fetch","fetchImplementation","globalVar","landedActionId","id","args","actionId","__routerActionID","temporaryReferences","payloadPromise","Request","href","body","method","headers","Accept","response","startTransition","Promise","resolve","payload","type","reload","isExternalLocation","navigate","replace","rerender","lastMatch","match","matches","patchRoutes","createRouteFromServerManifest","_internalSetStateDoNotUseOrYouWillBreakYourApp","Object","assign","actionResult","createRouterFromPayload","patches","Map","patch","parentId","has","set","get","push","reduceRight","previous","route","length","children","childrenToPatch","map","r","actionData","find","m","hydrateFallbackElement","path","signal","discoveredPaths","fetchAndApplyManifestPatches","getRSCSingleFetchDataStrategy","__routerInitialized","lastLoaderData","_updateRoutesForHMR","routeUpdateByRouteId","oldRoutes","newRoutes","walkRoutes","routes2","routeUpdate","routeModule","hasAction","hasComponent","hasErrorBoundary","newRoute","clientAction","errorElement","handle","index","links","meta","shouldRevalidate","updatedRoute","_internalSetRoutes","renderedRoutesContext","getRouter","M","hasClientLoader","hasClientAction","hasShouldRevalidate","getFetchAndDecodeViaRSC","runClientMiddleware","results","renderedRoutesById","renderedRoutes","rendered","trailingSlashAware","targetRoutes","request","url","searchParams","join","res","status","statusText","text","data","redirect","revalidate","dataKey","entries","RSCHydratedRouter","useMemo","setState","cloneRoutes","diffRoutes","transitionEnabledRouter","navigator","connection","saveData","registerElement","el","tagName","getAttribute","pathname","URL","origin","nextPaths","add","fetchPatches","paths","Array","from","keys","filter","delete","debouncedFetchPatches","debounce","observer","MutationObserver","observe","documentElement","subtree","childList","attributes","attributeFilter","frameworkContext","unstable_subResourceIntegrity","version","entry","module","imports","mode","manifestPath","hasInitialData","initialData","hasInitialError","initialError","isHydrationRequest","hydrate","dataRoute","loader","singleFetch","result","serverLoader","preventInvalidServerHandlerCall","callSingleFetch","_","action","serverAction","hasHandler","fn","msg","Set","discoveredPathsMaxSize","URL_LIMIT","getManifestUrl","sort","toString","clear","p","addToFifoQueue","queue","size","first","values","next","callback","wait","timeoutId","clearTimeout","setTimeout","newLocation","a","b","some","getRSCStream","encoder","TextEncoder","streamController","rscStream","ReadableStream","start","controller","handleChunk","chunk","enqueue","encode","__FLIGHT_DATA","readyState","addEventListener","close","unstable_RSCHydratedRouter","unstable_createCallServer","unstable_getRSCStream"],"sources":["C:/Users/Admin/Desktop/projects/react-phone-catalog/node_modules/react-router/dist/development/dom-export.mjs"],"sourcesContent":["/**\r\n * react-router v7.12.0\r\n *\r\n * Copyright (c) Remix Software Inc.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE.md file in the root directory of this source tree.\r\n *\r\n * @license MIT\r\n */\r\n\"use client\";\r\nimport {\r\n  RSCRouterGlobalErrorBoundary,\r\n  deserializeErrors,\r\n  getHydrationData,\r\n  populateRSCRouteModules\r\n} from \"./chunk-FNSCYPCZ.mjs\";\r\nimport {\r\n  CRITICAL_CSS_DATA_ATTRIBUTE,\r\n  ErrorResponseImpl,\r\n  FrameworkContext,\r\n  RSCRouterContext,\r\n  RemixErrorBoundary,\r\n  RouterProvider,\r\n  createBrowserHistory,\r\n  createClientRoutes,\r\n  createClientRoutesWithHMRRevalidationOptOut,\r\n  createContext,\r\n  createRequestInit,\r\n  createRouter,\r\n  decodeViaTurboStream,\r\n  getPatchRoutesOnNavigationFunction,\r\n  getSingleFetchDataStrategyImpl,\r\n  getTurboStreamSingleFetchDataStrategy,\r\n  hydrationRouteProperties,\r\n  invariant,\r\n  isMutationMethod,\r\n  mapRouteProperties,\r\n  noActionDefinedError,\r\n  setIsHydrated,\r\n  shouldHydrateRouteLoader,\r\n  singleFetchUrl,\r\n  stripIndexParam,\r\n  useFogOFWarDiscovery\r\n} from \"./chunk-EPOLDU6W.mjs\";\r\n\r\n// lib/dom-export/dom-router-provider.tsx\r\nimport * as React from \"react\";\r\nimport * as ReactDOM from \"react-dom\";\r\nfunction RouterProvider2(props) {\r\n  return /* @__PURE__ */ React.createElement(RouterProvider, { flushSync: ReactDOM.flushSync, ...props });\r\n}\r\n\r\n// lib/dom-export/hydrated-router.tsx\r\nimport * as React2 from \"react\";\r\nvar ssrInfo = null;\r\nvar router = null;\r\nfunction initSsrInfo() {\r\n  if (!ssrInfo && window.__reactRouterContext && window.__reactRouterManifest && window.__reactRouterRouteModules) {\r\n    if (window.__reactRouterManifest.sri === true) {\r\n      const importMap = document.querySelector(\"script[rr-importmap]\");\r\n      if (importMap?.textContent) {\r\n        try {\r\n          window.__reactRouterManifest.sri = JSON.parse(\r\n            importMap.textContent\r\n          ).integrity;\r\n        } catch (err) {\r\n          console.error(\"Failed to parse import map\", err);\r\n        }\r\n      }\r\n    }\r\n    ssrInfo = {\r\n      context: window.__reactRouterContext,\r\n      manifest: window.__reactRouterManifest,\r\n      routeModules: window.__reactRouterRouteModules,\r\n      stateDecodingPromise: void 0,\r\n      router: void 0,\r\n      routerInitialized: false\r\n    };\r\n  }\r\n}\r\nfunction createHydratedRouter({\r\n  getContext,\r\n  unstable_instrumentations\r\n}) {\r\n  initSsrInfo();\r\n  if (!ssrInfo) {\r\n    throw new Error(\r\n      \"You must be using the SSR features of React Router in order to skip passing a `router` prop to `<RouterProvider>`\"\r\n    );\r\n  }\r\n  let localSsrInfo = ssrInfo;\r\n  if (!ssrInfo.stateDecodingPromise) {\r\n    let stream = ssrInfo.context.stream;\r\n    invariant(stream, \"No stream found for single fetch decoding\");\r\n    ssrInfo.context.stream = void 0;\r\n    ssrInfo.stateDecodingPromise = decodeViaTurboStream(stream, window).then((value) => {\r\n      ssrInfo.context.state = value.value;\r\n      localSsrInfo.stateDecodingPromise.value = true;\r\n    }).catch((e) => {\r\n      localSsrInfo.stateDecodingPromise.error = e;\r\n    });\r\n  }\r\n  if (ssrInfo.stateDecodingPromise.error) {\r\n    throw ssrInfo.stateDecodingPromise.error;\r\n  }\r\n  if (!ssrInfo.stateDecodingPromise.value) {\r\n    throw ssrInfo.stateDecodingPromise;\r\n  }\r\n  let routes = createClientRoutes(\r\n    ssrInfo.manifest.routes,\r\n    ssrInfo.routeModules,\r\n    ssrInfo.context.state,\r\n    ssrInfo.context.ssr,\r\n    ssrInfo.context.isSpaMode\r\n  );\r\n  let hydrationData = void 0;\r\n  if (ssrInfo.context.isSpaMode) {\r\n    let { loaderData } = ssrInfo.context.state;\r\n    if (ssrInfo.manifest.routes.root?.hasLoader && loaderData && \"root\" in loaderData) {\r\n      hydrationData = {\r\n        loaderData: {\r\n          root: loaderData.root\r\n        }\r\n      };\r\n    }\r\n  } else {\r\n    hydrationData = getHydrationData({\r\n      state: ssrInfo.context.state,\r\n      routes,\r\n      getRouteInfo: (routeId) => ({\r\n        clientLoader: ssrInfo.routeModules[routeId]?.clientLoader,\r\n        hasLoader: ssrInfo.manifest.routes[routeId]?.hasLoader === true,\r\n        hasHydrateFallback: ssrInfo.routeModules[routeId]?.HydrateFallback != null\r\n      }),\r\n      location: window.location,\r\n      basename: window.__reactRouterContext?.basename,\r\n      isSpaMode: ssrInfo.context.isSpaMode\r\n    });\r\n    if (hydrationData && hydrationData.errors) {\r\n      hydrationData.errors = deserializeErrors(hydrationData.errors);\r\n    }\r\n  }\r\n  let router2 = createRouter({\r\n    routes,\r\n    history: createBrowserHistory(),\r\n    basename: ssrInfo.context.basename,\r\n    getContext,\r\n    hydrationData,\r\n    hydrationRouteProperties,\r\n    unstable_instrumentations,\r\n    mapRouteProperties,\r\n    future: {\r\n      middleware: ssrInfo.context.future.v8_middleware\r\n    },\r\n    dataStrategy: getTurboStreamSingleFetchDataStrategy(\r\n      () => router2,\r\n      ssrInfo.manifest,\r\n      ssrInfo.routeModules,\r\n      ssrInfo.context.ssr,\r\n      ssrInfo.context.basename,\r\n      ssrInfo.context.future.unstable_trailingSlashAwareDataRequests\r\n    ),\r\n    patchRoutesOnNavigation: getPatchRoutesOnNavigationFunction(\r\n      ssrInfo.manifest,\r\n      ssrInfo.routeModules,\r\n      ssrInfo.context.ssr,\r\n      ssrInfo.context.routeDiscovery,\r\n      ssrInfo.context.isSpaMode,\r\n      ssrInfo.context.basename\r\n    )\r\n  });\r\n  ssrInfo.router = router2;\r\n  if (router2.state.initialized) {\r\n    ssrInfo.routerInitialized = true;\r\n    router2.initialize();\r\n  }\r\n  router2.createRoutesForHMR = /* spacer so ts-ignore does not affect the right hand of the assignment */\r\n  createClientRoutesWithHMRRevalidationOptOut;\r\n  window.__reactRouterDataRouter = router2;\r\n  return router2;\r\n}\r\nfunction HydratedRouter(props) {\r\n  if (!router) {\r\n    router = createHydratedRouter({\r\n      getContext: props.getContext,\r\n      unstable_instrumentations: props.unstable_instrumentations\r\n    });\r\n  }\r\n  let [criticalCss, setCriticalCss] = React2.useState(\r\n    process.env.NODE_ENV === \"development\" ? ssrInfo?.context.criticalCss : void 0\r\n  );\r\n  React2.useEffect(() => {\r\n    if (process.env.NODE_ENV === \"development\") {\r\n      setCriticalCss(void 0);\r\n    }\r\n  }, []);\r\n  React2.useEffect(() => {\r\n    if (process.env.NODE_ENV === \"development\" && criticalCss === void 0) {\r\n      document.querySelectorAll(`[${CRITICAL_CSS_DATA_ATTRIBUTE}]`).forEach((element) => element.remove());\r\n    }\r\n  }, [criticalCss]);\r\n  let [location2, setLocation] = React2.useState(router.state.location);\r\n  React2.useLayoutEffect(() => {\r\n    if (ssrInfo && ssrInfo.router && !ssrInfo.routerInitialized) {\r\n      ssrInfo.routerInitialized = true;\r\n      ssrInfo.router.initialize();\r\n    }\r\n  }, []);\r\n  React2.useLayoutEffect(() => {\r\n    if (ssrInfo && ssrInfo.router) {\r\n      return ssrInfo.router.subscribe((newState) => {\r\n        if (newState.location !== location2) {\r\n          setLocation(newState.location);\r\n        }\r\n      });\r\n    }\r\n  }, [location2]);\r\n  invariant(ssrInfo, \"ssrInfo unavailable for HydratedRouter\");\r\n  useFogOFWarDiscovery(\r\n    router,\r\n    ssrInfo.manifest,\r\n    ssrInfo.routeModules,\r\n    ssrInfo.context.ssr,\r\n    ssrInfo.context.routeDiscovery,\r\n    ssrInfo.context.isSpaMode\r\n  );\r\n  return (\r\n    // This fragment is important to ensure we match the <ServerRouter> JSX\r\n    // structure so that useId values hydrate correctly\r\n    /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(\r\n      FrameworkContext.Provider,\r\n      {\r\n        value: {\r\n          manifest: ssrInfo.manifest,\r\n          routeModules: ssrInfo.routeModules,\r\n          future: ssrInfo.context.future,\r\n          criticalCss,\r\n          ssr: ssrInfo.context.ssr,\r\n          isSpaMode: ssrInfo.context.isSpaMode,\r\n          routeDiscovery: ssrInfo.context.routeDiscovery\r\n        }\r\n      },\r\n      /* @__PURE__ */ React2.createElement(RemixErrorBoundary, { location: location2 }, /* @__PURE__ */ React2.createElement(\r\n        RouterProvider2,\r\n        {\r\n          router,\r\n          unstable_useTransitions: props.unstable_useTransitions,\r\n          onError: props.onError\r\n        }\r\n      ))\r\n    ), /* @__PURE__ */ React2.createElement(React2.Fragment, null))\r\n  );\r\n}\r\n\r\n// lib/rsc/browser.tsx\r\nimport * as React3 from \"react\";\r\nimport * as ReactDOM2 from \"react-dom\";\r\nfunction createCallServer({\r\n  createFromReadableStream,\r\n  createTemporaryReferenceSet,\r\n  encodeReply,\r\n  fetch: fetchImplementation = fetch\r\n}) {\r\n  const globalVar = window;\r\n  let landedActionId = 0;\r\n  return async (id, args) => {\r\n    let actionId = globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\r\n    const temporaryReferences = createTemporaryReferenceSet();\r\n    const payloadPromise = fetchImplementation(\r\n      new Request(location.href, {\r\n        body: await encodeReply(args, { temporaryReferences }),\r\n        method: \"POST\",\r\n        headers: {\r\n          Accept: \"text/x-component\",\r\n          \"rsc-action-id\": id\r\n        }\r\n      })\r\n    ).then((response) => {\r\n      if (!response.body) {\r\n        throw new Error(\"No response body\");\r\n      }\r\n      return createFromReadableStream(response.body, {\r\n        temporaryReferences\r\n      });\r\n    });\r\n    React3.startTransition(\r\n      () => (\r\n        // @ts-expect-error - Needs React 19 types\r\n        Promise.resolve(payloadPromise).then(async (payload) => {\r\n          if (payload.type === \"redirect\") {\r\n            if (payload.reload || isExternalLocation(payload.location)) {\r\n              window.location.href = payload.location;\r\n              return;\r\n            }\r\n            React3.startTransition(() => {\r\n              globalVar.__reactRouterDataRouter.navigate(payload.location, {\r\n                replace: payload.replace\r\n              });\r\n            });\r\n            return;\r\n          }\r\n          if (payload.type !== \"action\") {\r\n            throw new Error(\"Unexpected payload type\");\r\n          }\r\n          const rerender = await payload.rerender;\r\n          if (rerender && landedActionId < actionId && globalVar.__routerActionID <= actionId) {\r\n            if (rerender.type === \"redirect\") {\r\n              if (rerender.reload || isExternalLocation(rerender.location)) {\r\n                window.location.href = rerender.location;\r\n                return;\r\n              }\r\n              React3.startTransition(() => {\r\n                globalVar.__reactRouterDataRouter.navigate(rerender.location, {\r\n                  replace: rerender.replace\r\n                });\r\n              });\r\n              return;\r\n            }\r\n            React3.startTransition(() => {\r\n              let lastMatch;\r\n              for (const match of rerender.matches) {\r\n                globalVar.__reactRouterDataRouter.patchRoutes(\r\n                  lastMatch?.id ?? null,\r\n                  [createRouteFromServerManifest(match)],\r\n                  true\r\n                );\r\n                lastMatch = match;\r\n              }\r\n              window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(\r\n                {\r\n                  loaderData: Object.assign(\r\n                    {},\r\n                    globalVar.__reactRouterDataRouter.state.loaderData,\r\n                    rerender.loaderData\r\n                  ),\r\n                  errors: rerender.errors ? Object.assign(\r\n                    {},\r\n                    globalVar.__reactRouterDataRouter.state.errors,\r\n                    rerender.errors\r\n                  ) : null\r\n                }\r\n              );\r\n            });\r\n          }\r\n        }).catch(() => {\r\n        })\r\n      )\r\n    );\r\n    return payloadPromise.then((payload) => {\r\n      if (payload.type !== \"action\" && payload.type !== \"redirect\") {\r\n        throw new Error(\"Unexpected payload type\");\r\n      }\r\n      return payload.actionResult;\r\n    });\r\n  };\r\n}\r\nfunction createRouterFromPayload({\r\n  fetchImplementation,\r\n  createFromReadableStream,\r\n  getContext,\r\n  payload\r\n}) {\r\n  const globalVar = window;\r\n  if (globalVar.__reactRouterDataRouter && globalVar.__reactRouterRouteModules)\r\n    return {\r\n      router: globalVar.__reactRouterDataRouter,\r\n      routeModules: globalVar.__reactRouterRouteModules\r\n    };\r\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\r\n  globalVar.__reactRouterRouteModules = globalVar.__reactRouterRouteModules ?? {};\r\n  populateRSCRouteModules(globalVar.__reactRouterRouteModules, payload.matches);\r\n  let patches = /* @__PURE__ */ new Map();\r\n  payload.patches?.forEach((patch) => {\r\n    invariant(patch.parentId, \"Invalid patch parentId\");\r\n    if (!patches.has(patch.parentId)) {\r\n      patches.set(patch.parentId, []);\r\n    }\r\n    patches.get(patch.parentId)?.push(patch);\r\n  });\r\n  let routes = payload.matches.reduceRight((previous, match) => {\r\n    const route = createRouteFromServerManifest(\r\n      match,\r\n      payload\r\n    );\r\n    if (previous.length > 0) {\r\n      route.children = previous;\r\n      let childrenToPatch = patches.get(match.id);\r\n      if (childrenToPatch) {\r\n        route.children.push(\r\n          ...childrenToPatch.map((r) => createRouteFromServerManifest(r))\r\n        );\r\n      }\r\n    }\r\n    return [route];\r\n  }, []);\r\n  globalVar.__reactRouterDataRouter = createRouter({\r\n    routes,\r\n    getContext,\r\n    basename: payload.basename,\r\n    history: createBrowserHistory(),\r\n    hydrationData: getHydrationData({\r\n      state: {\r\n        loaderData: payload.loaderData,\r\n        actionData: payload.actionData,\r\n        errors: payload.errors\r\n      },\r\n      routes,\r\n      getRouteInfo: (routeId) => {\r\n        let match = payload.matches.find((m) => m.id === routeId);\r\n        invariant(match, \"Route not found in payload\");\r\n        return {\r\n          clientLoader: match.clientLoader,\r\n          hasLoader: match.hasLoader,\r\n          hasHydrateFallback: match.hydrateFallbackElement != null\r\n        };\r\n      },\r\n      location: payload.location,\r\n      basename: payload.basename,\r\n      isSpaMode: false\r\n    }),\r\n    async patchRoutesOnNavigation({ path, signal }) {\r\n      if (discoveredPaths.has(path)) {\r\n        return;\r\n      }\r\n      await fetchAndApplyManifestPatches(\r\n        [path],\r\n        createFromReadableStream,\r\n        fetchImplementation,\r\n        signal\r\n      );\r\n    },\r\n    // FIXME: Pass `build.ssr` into this function\r\n    dataStrategy: getRSCSingleFetchDataStrategy(\r\n      () => globalVar.__reactRouterDataRouter,\r\n      true,\r\n      payload.basename,\r\n      createFromReadableStream,\r\n      fetchImplementation\r\n    )\r\n  });\r\n  if (globalVar.__reactRouterDataRouter.state.initialized) {\r\n    globalVar.__routerInitialized = true;\r\n    globalVar.__reactRouterDataRouter.initialize();\r\n  } else {\r\n    globalVar.__routerInitialized = false;\r\n  }\r\n  let lastLoaderData = void 0;\r\n  globalVar.__reactRouterDataRouter.subscribe(({ loaderData, actionData }) => {\r\n    if (lastLoaderData !== loaderData) {\r\n      globalVar.__routerActionID = (globalVar.__routerActionID ?? (globalVar.__routerActionID = 0)) + 1;\r\n    }\r\n  });\r\n  globalVar.__reactRouterDataRouter._updateRoutesForHMR = (routeUpdateByRouteId) => {\r\n    const oldRoutes = window.__reactRouterDataRouter.routes;\r\n    const newRoutes = [];\r\n    function walkRoutes(routes2, parentId) {\r\n      return routes2.map((route) => {\r\n        const routeUpdate = routeUpdateByRouteId.get(route.id);\r\n        if (routeUpdate) {\r\n          const {\r\n            routeModule,\r\n            hasAction,\r\n            hasComponent,\r\n            hasErrorBoundary,\r\n            hasLoader\r\n          } = routeUpdate;\r\n          const newRoute = createRouteFromServerManifest({\r\n            clientAction: routeModule.clientAction,\r\n            clientLoader: routeModule.clientLoader,\r\n            element: route.element,\r\n            errorElement: route.errorElement,\r\n            handle: route.handle,\r\n            hasAction,\r\n            hasComponent,\r\n            hasErrorBoundary,\r\n            hasLoader,\r\n            hydrateFallbackElement: route.hydrateFallbackElement,\r\n            id: route.id,\r\n            index: route.index,\r\n            links: routeModule.links,\r\n            meta: routeModule.meta,\r\n            parentId,\r\n            path: route.path,\r\n            shouldRevalidate: routeModule.shouldRevalidate\r\n          });\r\n          if (route.children) {\r\n            newRoute.children = walkRoutes(route.children, route.id);\r\n          }\r\n          return newRoute;\r\n        }\r\n        const updatedRoute = { ...route };\r\n        if (route.children) {\r\n          updatedRoute.children = walkRoutes(route.children, route.id);\r\n        }\r\n        return updatedRoute;\r\n      });\r\n    }\r\n    newRoutes.push(\r\n      ...walkRoutes(oldRoutes, void 0)\r\n    );\r\n    window.__reactRouterDataRouter._internalSetRoutes(newRoutes);\r\n  };\r\n  return {\r\n    router: globalVar.__reactRouterDataRouter,\r\n    routeModules: globalVar.__reactRouterRouteModules\r\n  };\r\n}\r\nvar renderedRoutesContext = createContext();\r\nfunction getRSCSingleFetchDataStrategy(getRouter, ssr, basename, createFromReadableStream, fetchImplementation) {\r\n  let dataStrategy = getSingleFetchDataStrategyImpl(\r\n    getRouter,\r\n    (match) => {\r\n      let M = match;\r\n      return {\r\n        hasLoader: M.route.hasLoader,\r\n        hasClientLoader: M.route.hasClientLoader,\r\n        hasComponent: M.route.hasComponent,\r\n        hasAction: M.route.hasAction,\r\n        hasClientAction: M.route.hasClientAction,\r\n        hasShouldRevalidate: M.route.hasShouldRevalidate\r\n      };\r\n    },\r\n    // pass map into fetchAndDecode so it can add payloads\r\n    getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation),\r\n    ssr,\r\n    basename,\r\n    // .rsc requests are always trailing slash aware\r\n    true,\r\n    // If the route has a component but we don't have an element, we need to hit\r\n    // the server loader flow regardless of whether the client loader calls\r\n    // `serverLoader` or not, otherwise we'll have nothing to render.\r\n    (match) => {\r\n      let M = match;\r\n      return M.route.hasComponent && !M.route.element;\r\n    }\r\n  );\r\n  return async (args) => args.runClientMiddleware(async () => {\r\n    let context = args.context;\r\n    context.set(renderedRoutesContext, []);\r\n    let results = await dataStrategy(args);\r\n    const renderedRoutesById = /* @__PURE__ */ new Map();\r\n    for (const route of context.get(renderedRoutesContext)) {\r\n      if (!renderedRoutesById.has(route.id)) {\r\n        renderedRoutesById.set(route.id, []);\r\n      }\r\n      renderedRoutesById.get(route.id).push(route);\r\n    }\r\n    React3.startTransition(() => {\r\n      for (const match of args.matches) {\r\n        const renderedRoutes = renderedRoutesById.get(match.route.id);\r\n        if (renderedRoutes) {\r\n          for (const rendered of renderedRoutes) {\r\n            window.__reactRouterDataRouter.patchRoutes(\r\n              rendered.parentId ?? null,\r\n              [createRouteFromServerManifest(rendered)],\r\n              true\r\n            );\r\n          }\r\n        }\r\n      }\r\n    });\r\n    return results;\r\n  });\r\n}\r\nfunction getFetchAndDecodeViaRSC(createFromReadableStream, fetchImplementation) {\r\n  return async (args, basename, trailingSlashAware, targetRoutes) => {\r\n    let { request, context } = args;\r\n    let url = singleFetchUrl(request.url, basename, trailingSlashAware, \"rsc\");\r\n    if (request.method === \"GET\") {\r\n      url = stripIndexParam(url);\r\n      if (targetRoutes) {\r\n        url.searchParams.set(\"_routes\", targetRoutes.join(\",\"));\r\n      }\r\n    }\r\n    let res = await fetchImplementation(\r\n      new Request(url, await createRequestInit(request))\r\n    );\r\n    if (res.status >= 400 && !res.headers.has(\"X-Remix-Response\")) {\r\n      throw new ErrorResponseImpl(res.status, res.statusText, await res.text());\r\n    }\r\n    invariant(res.body, \"No response body to decode\");\r\n    try {\r\n      const payload = await createFromReadableStream(res.body, {\r\n        temporaryReferences: void 0\r\n      });\r\n      if (payload.type === \"redirect\") {\r\n        return {\r\n          status: res.status,\r\n          data: {\r\n            redirect: {\r\n              redirect: payload.location,\r\n              reload: payload.reload,\r\n              replace: payload.replace,\r\n              revalidate: false,\r\n              status: payload.status\r\n            }\r\n          }\r\n        };\r\n      }\r\n      if (payload.type !== \"render\") {\r\n        throw new Error(\"Unexpected payload type\");\r\n      }\r\n      context.get(renderedRoutesContext).push(...payload.matches);\r\n      let results = { routes: {} };\r\n      const dataKey = isMutationMethod(request.method) ? \"actionData\" : \"loaderData\";\r\n      for (let [routeId, data] of Object.entries(payload[dataKey] || {})) {\r\n        results.routes[routeId] = { data };\r\n      }\r\n      if (payload.errors) {\r\n        for (let [routeId, error] of Object.entries(payload.errors)) {\r\n          results.routes[routeId] = { error };\r\n        }\r\n      }\r\n      return { status: res.status, data: results };\r\n    } catch (e) {\r\n      throw new Error(\"Unable to decode RSC response\");\r\n    }\r\n  };\r\n}\r\nfunction RSCHydratedRouter({\r\n  createFromReadableStream,\r\n  fetch: fetchImplementation = fetch,\r\n  payload,\r\n  routeDiscovery = \"eager\",\r\n  getContext\r\n}) {\r\n  if (payload.type !== \"render\") throw new Error(\"Invalid payload type\");\r\n  let { router: router2, routeModules } = React3.useMemo(\r\n    () => createRouterFromPayload({\r\n      payload,\r\n      fetchImplementation,\r\n      getContext,\r\n      createFromReadableStream\r\n    }),\r\n    [createFromReadableStream, payload, fetchImplementation, getContext]\r\n  );\r\n  React3.useEffect(() => {\r\n    setIsHydrated();\r\n  }, []);\r\n  React3.useLayoutEffect(() => {\r\n    const globalVar = window;\r\n    if (!globalVar.__routerInitialized) {\r\n      globalVar.__routerInitialized = true;\r\n      globalVar.__reactRouterDataRouter.initialize();\r\n    }\r\n  }, []);\r\n  let [{ routes, state }, setState] = React3.useState(() => ({\r\n    routes: cloneRoutes(router2.routes),\r\n    state: router2.state\r\n  }));\r\n  React3.useLayoutEffect(\r\n    () => router2.subscribe((newState) => {\r\n      if (diffRoutes(router2.routes, routes))\r\n        React3.startTransition(() => {\r\n          setState({\r\n            routes: cloneRoutes(router2.routes),\r\n            state: newState\r\n          });\r\n        });\r\n    }),\r\n    [router2.subscribe, routes, router2]\r\n  );\r\n  const transitionEnabledRouter = React3.useMemo(\r\n    () => ({\r\n      ...router2,\r\n      state,\r\n      routes\r\n    }),\r\n    [router2, routes, state]\r\n  );\r\n  React3.useEffect(() => {\r\n    if (routeDiscovery === \"lazy\" || // @ts-expect-error - TS doesn't know about this yet\r\n    window.navigator?.connection?.saveData === true) {\r\n      return;\r\n    }\r\n    function registerElement(el) {\r\n      let path = el.tagName === \"FORM\" ? el.getAttribute(\"action\") : el.getAttribute(\"href\");\r\n      if (!path) {\r\n        return;\r\n      }\r\n      let pathname = el.tagName === \"A\" ? el.pathname : new URL(path, window.location.origin).pathname;\r\n      if (!discoveredPaths.has(pathname)) {\r\n        nextPaths.add(pathname);\r\n      }\r\n    }\r\n    async function fetchPatches() {\r\n      document.querySelectorAll(\"a[data-discover], form[data-discover]\").forEach(registerElement);\r\n      let paths = Array.from(nextPaths.keys()).filter((path) => {\r\n        if (discoveredPaths.has(path)) {\r\n          nextPaths.delete(path);\r\n          return false;\r\n        }\r\n        return true;\r\n      });\r\n      if (paths.length === 0) {\r\n        return;\r\n      }\r\n      try {\r\n        await fetchAndApplyManifestPatches(\r\n          paths,\r\n          createFromReadableStream,\r\n          fetchImplementation\r\n        );\r\n      } catch (e) {\r\n        console.error(\"Failed to fetch manifest patches\", e);\r\n      }\r\n    }\r\n    let debouncedFetchPatches = debounce(fetchPatches, 100);\r\n    fetchPatches();\r\n    let observer = new MutationObserver(() => debouncedFetchPatches());\r\n    observer.observe(document.documentElement, {\r\n      subtree: true,\r\n      childList: true,\r\n      attributes: true,\r\n      attributeFilter: [\"data-discover\", \"href\", \"action\"]\r\n    });\r\n  }, [routeDiscovery, createFromReadableStream, fetchImplementation]);\r\n  const frameworkContext = {\r\n    future: {\r\n      // These flags have no runtime impact so can always be false.  If we add\r\n      // flags that drive runtime behavior they'll need to be proxied through.\r\n      v8_middleware: false,\r\n      unstable_subResourceIntegrity: false,\r\n      unstable_trailingSlashAwareDataRequests: true\r\n      // always on for RSC\r\n    },\r\n    isSpaMode: false,\r\n    ssr: true,\r\n    criticalCss: \"\",\r\n    manifest: {\r\n      routes: {},\r\n      version: \"1\",\r\n      url: \"\",\r\n      entry: {\r\n        module: \"\",\r\n        imports: []\r\n      }\r\n    },\r\n    routeDiscovery: { mode: \"lazy\", manifestPath: \"/__manifest\" },\r\n    routeModules\r\n  };\r\n  return /* @__PURE__ */ React3.createElement(RSCRouterContext.Provider, { value: true }, /* @__PURE__ */ React3.createElement(RSCRouterGlobalErrorBoundary, { location: state.location }, /* @__PURE__ */ React3.createElement(FrameworkContext.Provider, { value: frameworkContext }, /* @__PURE__ */ React3.createElement(\r\n    RouterProvider,\r\n    {\r\n      router: transitionEnabledRouter,\r\n      flushSync: ReactDOM2.flushSync\r\n    }\r\n  ))));\r\n}\r\nfunction createRouteFromServerManifest(match, payload) {\r\n  let hasInitialData = payload && match.id in payload.loaderData;\r\n  let initialData = payload?.loaderData[match.id];\r\n  let hasInitialError = payload?.errors && match.id in payload.errors;\r\n  let initialError = payload?.errors?.[match.id];\r\n  let isHydrationRequest = match.clientLoader?.hydrate === true || !match.hasLoader || // If the route has a component but we don't have an element, we need to hit\r\n  // the server loader flow regardless of whether the client loader calls\r\n  // `serverLoader` or not, otherwise we'll have nothing to render.\r\n  match.hasComponent && !match.element;\r\n  invariant(window.__reactRouterRouteModules);\r\n  populateRSCRouteModules(window.__reactRouterRouteModules, match);\r\n  let dataRoute = {\r\n    id: match.id,\r\n    element: match.element,\r\n    errorElement: match.errorElement,\r\n    handle: match.handle,\r\n    hasErrorBoundary: match.hasErrorBoundary,\r\n    hydrateFallbackElement: match.hydrateFallbackElement,\r\n    index: match.index,\r\n    loader: match.clientLoader ? async (args, singleFetch) => {\r\n      try {\r\n        let result = await match.clientLoader({\r\n          ...args,\r\n          serverLoader: () => {\r\n            preventInvalidServerHandlerCall(\r\n              \"loader\",\r\n              match.id,\r\n              match.hasLoader\r\n            );\r\n            if (isHydrationRequest) {\r\n              if (hasInitialData) {\r\n                return initialData;\r\n              }\r\n              if (hasInitialError) {\r\n                throw initialError;\r\n              }\r\n            }\r\n            return callSingleFetch(singleFetch);\r\n          }\r\n        });\r\n        return result;\r\n      } finally {\r\n        isHydrationRequest = false;\r\n      }\r\n    } : (\r\n      // We always make the call in this RSC world since even if we don't\r\n      // have a `loader` we may need to get the `element` implementation\r\n      (_, singleFetch) => callSingleFetch(singleFetch)\r\n    ),\r\n    action: match.clientAction ? (args, singleFetch) => match.clientAction({\r\n      ...args,\r\n      serverAction: async () => {\r\n        preventInvalidServerHandlerCall(\r\n          \"action\",\r\n          match.id,\r\n          match.hasLoader\r\n        );\r\n        return await callSingleFetch(singleFetch);\r\n      }\r\n    }) : match.hasAction ? (_, singleFetch) => callSingleFetch(singleFetch) : () => {\r\n      throw noActionDefinedError(\"action\", match.id);\r\n    },\r\n    path: match.path,\r\n    shouldRevalidate: match.shouldRevalidate,\r\n    // We always have a \"loader\" in this RSC world since even if we don't\r\n    // have a `loader` we may need to get the `element` implementation\r\n    hasLoader: true,\r\n    hasClientLoader: match.clientLoader != null,\r\n    hasAction: match.hasAction,\r\n    hasClientAction: match.clientAction != null,\r\n    hasShouldRevalidate: match.shouldRevalidate != null\r\n  };\r\n  if (typeof dataRoute.loader === \"function\") {\r\n    dataRoute.loader.hydrate = shouldHydrateRouteLoader(\r\n      match.id,\r\n      match.clientLoader,\r\n      match.hasLoader,\r\n      false\r\n    );\r\n  }\r\n  return dataRoute;\r\n}\r\nfunction callSingleFetch(singleFetch) {\r\n  invariant(typeof singleFetch === \"function\", \"Invalid singleFetch parameter\");\r\n  return singleFetch();\r\n}\r\nfunction preventInvalidServerHandlerCall(type, routeId, hasHandler) {\r\n  if (!hasHandler) {\r\n    let fn = type === \"action\" ? \"serverAction()\" : \"serverLoader()\";\r\n    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: \"${routeId}\")`;\r\n    console.error(msg);\r\n    throw new ErrorResponseImpl(400, \"Bad Request\", new Error(msg), true);\r\n  }\r\n}\r\nvar nextPaths = /* @__PURE__ */ new Set();\r\nvar discoveredPathsMaxSize = 1e3;\r\nvar discoveredPaths = /* @__PURE__ */ new Set();\r\nvar URL_LIMIT = 7680;\r\nfunction getManifestUrl(paths) {\r\n  if (paths.length === 0) {\r\n    return null;\r\n  }\r\n  if (paths.length === 1) {\r\n    return new URL(`${paths[0]}.manifest`, window.location.origin);\r\n  }\r\n  const globalVar = window;\r\n  let basename = (globalVar.__reactRouterDataRouter.basename ?? \"\").replace(\r\n    /^\\/|\\/$/g,\r\n    \"\"\r\n  );\r\n  let url = new URL(`${basename}/.manifest`, window.location.origin);\r\n  url.searchParams.set(\"paths\", paths.sort().join(\",\"));\r\n  return url;\r\n}\r\nasync function fetchAndApplyManifestPatches(paths, createFromReadableStream, fetchImplementation, signal) {\r\n  let url = getManifestUrl(paths);\r\n  if (url == null) {\r\n    return;\r\n  }\r\n  if (url.toString().length > URL_LIMIT) {\r\n    nextPaths.clear();\r\n    return;\r\n  }\r\n  let response = await fetchImplementation(new Request(url, { signal }));\r\n  if (!response.body || response.status < 200 || response.status >= 300) {\r\n    throw new Error(\"Unable to fetch new route matches from the server\");\r\n  }\r\n  let payload = await createFromReadableStream(response.body, {\r\n    temporaryReferences: void 0\r\n  });\r\n  if (payload.type !== \"manifest\") {\r\n    throw new Error(\"Failed to patch routes\");\r\n  }\r\n  paths.forEach((p) => addToFifoQueue(p, discoveredPaths));\r\n  React3.startTransition(() => {\r\n    payload.patches.forEach((p) => {\r\n      window.__reactRouterDataRouter.patchRoutes(\r\n        p.parentId ?? null,\r\n        [createRouteFromServerManifest(p)]\r\n      );\r\n    });\r\n  });\r\n}\r\nfunction addToFifoQueue(path, queue) {\r\n  if (queue.size >= discoveredPathsMaxSize) {\r\n    let first = queue.values().next().value;\r\n    if (typeof first === \"string\") queue.delete(first);\r\n  }\r\n  queue.add(path);\r\n}\r\nfunction debounce(callback, wait) {\r\n  let timeoutId;\r\n  return (...args) => {\r\n    window.clearTimeout(timeoutId);\r\n    timeoutId = window.setTimeout(() => callback(...args), wait);\r\n  };\r\n}\r\nfunction isExternalLocation(location2) {\r\n  const newLocation = new URL(location2, window.location.href);\r\n  return newLocation.origin !== window.location.origin;\r\n}\r\nfunction cloneRoutes(routes) {\r\n  if (!routes) return void 0;\r\n  return routes.map((route) => ({\r\n    ...route,\r\n    children: cloneRoutes(route.children)\r\n  }));\r\n}\r\nfunction diffRoutes(a, b) {\r\n  if (a.length !== b.length) return true;\r\n  return a.some((route, index) => {\r\n    if (route.element !== b[index].element) return true;\r\n    if (route.errorElement !== b[index].errorElement)\r\n      return true;\r\n    if (route.hydrateFallbackElement !== b[index].hydrateFallbackElement)\r\n      return true;\r\n    if (route.hasErrorBoundary !== b[index].hasErrorBoundary)\r\n      return true;\r\n    if (route.hasLoader !== b[index].hasLoader) return true;\r\n    if (route.hasClientLoader !== b[index].hasClientLoader)\r\n      return true;\r\n    if (route.hasAction !== b[index].hasAction) return true;\r\n    if (route.hasClientAction !== b[index].hasClientAction)\r\n      return true;\r\n    return diffRoutes(route.children || [], b[index].children || []);\r\n  });\r\n}\r\n\r\n// lib/rsc/html-stream/browser.ts\r\nfunction getRSCStream() {\r\n  let encoder = new TextEncoder();\r\n  let streamController = null;\r\n  let rscStream = new ReadableStream({\r\n    start(controller) {\r\n      if (typeof window === \"undefined\") {\r\n        return;\r\n      }\r\n      let handleChunk = (chunk) => {\r\n        if (typeof chunk === \"string\") {\r\n          controller.enqueue(encoder.encode(chunk));\r\n        } else {\r\n          controller.enqueue(chunk);\r\n        }\r\n      };\r\n      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []);\r\n      window.__FLIGHT_DATA.forEach(handleChunk);\r\n      window.__FLIGHT_DATA.push = (chunk) => {\r\n        handleChunk(chunk);\r\n        return 0;\r\n      };\r\n      streamController = controller;\r\n    }\r\n  });\r\n  if (typeof document !== \"undefined\" && document.readyState === \"loading\") {\r\n    document.addEventListener(\"DOMContentLoaded\", () => {\r\n      streamController?.close();\r\n    });\r\n  } else {\r\n    streamController?.close();\r\n  }\r\n  return rscStream;\r\n}\r\nexport {\r\n  HydratedRouter,\r\n  RouterProvider2 as RouterProvider,\r\n  RSCHydratedRouter as unstable_RSCHydratedRouter,\r\n  createCallServer as unstable_createCallServer,\r\n  getRSCStream as unstable_getRSCStream\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}